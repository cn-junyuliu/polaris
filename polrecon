#!/usr/bin/env python

# Imports
import argparse
import logging
import datetime
import subprocess
import sys
import dill

# Check stdin for files names
if not sys.stdin.isatty():
    cal_file = sys.stdin.readline()
    sys.stdin = open('/dev/tty') # need for pdb
else:
    cal_file = None

# Parse arguments
parser = argparse.ArgumentParser()
parser.add_argument('-c', '--calibration-filename', nargs='?', 
                    default=cal_file, help='Specify the output filename.')

parser.add_argument('-d', '--data-folder', 
                    help='Specify the input data folder.')

parser.add_argument('-o', '--output-filename', default='output.vtu', 
                    help='Specify the output filename.')

parser.add_argument('-l', '--log-filename', default='polrecon.log', 
                    help='Specify the log filename.')

parser.add_argument('-n', '--n-angle-pts', type=int, default=500, 
                    help='The number of angular points to reconstruct.')

arg = parser.parse_args()


# Setup logging
log = logging.getLogger('recon')
log.setLevel(logging.DEBUG)
ch = logging.StreamHandler()
ch.setLevel(logging.DEBUG)
log.addHandler(ch)
fh = logging.FileHandler(arg.log_filename, mode='w')
fh.setLevel(logging.DEBUG) 
log.addHandler(fh)

# Log basics
log.info('-----polrecon-----')
log.info('Platform:\t'+sys.platform)
v = subprocess.Popen(['git', 'rev-parse', '--short', 'HEAD'],
                     cwd='/'.join(__file__.split('/')[:-1])+'/',
                     stdout=subprocess.PIPE).communicate()[0]
log.info('Version:\t'+v.strip().decode('ascii'))
log.info('Time:\t\t'+datetime.datetime.now().replace(microsecond=0).isoformat())
log.info('Command:\t'+' '.join(sys.argv))

# Main script

# Load calibration file
try:
    log.info("Loading:\t" + arg.calibration_filename)    
    f = open(arg.calibration_filename, 'rb')
    exp = dill.load(f)
except:
    log.info("WARNING:\tCouldn't read calibration file.")

# Calculate B matric
exp.n_angle_pts = arg.n_angle_pts
exp.calc_B_matrix()

# Load data into memory
import numpy as np
names = ['A_reg_P3.tif', 'A_reg_P4.tif', 'A_reg_P1.tif', 'A_reg_P2.tif',
         'B_reg_P3.tif', 'B_reg_P4.tif', 'B_reg_P1.tif', 'B_reg_P2.tif']
input_files = np.array([arg.data_folder + name for name in names])
cal = np.array([1.06, 1.0, 1.0, 1.03, 
                1.08, 1.05, 1.0, 1.04])

# Reindexing 
idx = [0, 3, 2, 1, 4, 5, 6, 7]
input_files = input_files[idx]
cal = cal[idx]

# Load intensity field
from polaris import data
intf = data.IntensityField()
xs=100
ys=100
zs=40
x0=180
y0=545
z0=150
intf.load_from_file(file_names=input_files, x0=x0, y0=y0, z0=z0, xspan=xs, yspan=ys, zspan=zs, cal=cal)

# Mask
recon_mask_threshold=0.4
skip=3
threshold_mask = np.max(intf.g, axis=-1) > recon_mask_threshold
sparse_mask = np.zeros(threshold_mask.shape)
sparse_mask[::skip, ::skip, ::skip] = 1
mask = np.logical_and(threshold_mask, sparse_mask)

# Reconstruct
df = exp.recon_dist_field(intf, mask=mask, prior='single')

# Shuffle data for saving
x, y, z, tp = np.nonzero(df.f_arr)
u = exp.xyz[tp, 0]
v = exp.xyz[tp, 1]
w = exp.xyz[tp, 2]

from pyevtk.hl import pointsToVTK
import numpy as np
pointsToVTK("./line_points",
            x.astype('float'), y.astype('float'), z.astype('float'),
            data = {"uvw" : (u,v,w)})

# Pass on output file.
log.info('stdout:\t\t'+arg.output_filename)
sys.stdout.write(arg.output_filename)
