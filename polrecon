#!/usr/bin/env python

# Imports
import argparse
import logging
import datetime
import subprocess
import sys
import dill
import time; start = time.time();

# Check stdin for files names
if not sys.stdin.isatty():
    cal_file = sys.stdin.readline()
    sys.stdin = open('/dev/tty') # need for pdb
else:
    cal_file = None

# Parse arguments
parser = argparse.ArgumentParser()
parser.add_argument('-c', '--calibration-filename', nargs='?', 
                    default=None, help='Specify the output filename.')

parser.add_argument('-d', '--data-folder', 
                    help='Specify the input data folder.')

parser.add_argument('-o', '--output-filename', default='output', 
                    help='Specify the output filename.')

parser.add_argument('-l', '--log-filename', default='polrecon.log', 
                    help='Specify the log filename.')

parser.add_argument('-n', '--n-angle-pts', type=int, default=500, 
                    help='The number of angular points to reconstruct.')

parser.add_argument('--reindex', nargs='+', type=int,
                    default=[0, 3, 2, 1, 4, 5, 6, 7], 
                    help='Reorder the data files to match the .cal file.')

parser.add_argument('--span', nargs=3, type=int,
                    default=[100, 100, 40], 
                    help='Size in pixels of the reconstructed ROI. [x, y, z]')

parser.add_argument('--origin', nargs=3, type=int,
                    default=[180, 545, 150], 
                    help='Origin of ROI in pixel coordinates. [x, y, z]')

parser.add_argument('--recon-threshold', type=float, default=0.4, 
                    help='Threshold for reconstructing the voxel.')

parser.add_argument('--skip', type=int, default=3, 
                    help='Skip every x voxels for reconstruction.')

parser.add_argument('--prior', default='single', help="'single', 'none'")
                    
arg = parser.parse_args()

# Setup logging
log = logging.getLogger('recon')
log.setLevel(logging.DEBUG)
ch = logging.StreamHandler()
ch.setLevel(logging.DEBUG)
log.addHandler(ch)
fh = logging.FileHandler(arg.log_filename, mode='w')
fh.setLevel(logging.DEBUG) 
log.addHandler(fh)

# Log basics
log.info('-----polrecon-----')
log.info('Platform:\t'+sys.platform)
v = subprocess.Popen(['git', 'rev-parse', '--short', 'HEAD'],
                     cwd='/'.join(__file__.split('/')[:-1])+'/',
                     stdout=subprocess.PIPE).communicate()[0]
log.info('Version:\t'+v.strip().decode('ascii'))
log.info('Time:\t\t'+datetime.datetime.now().replace(microsecond=0).isoformat())
log.info('Command:\t'+' '.join(sys.argv))

# Main script

# Load calibration file
try:
    log.info("Loading:\t" + arg.calibration_filename)    
    f = open(arg.calibration_filename, 'rb')
    exp = dill.load(f)
except:
    log.info("WARNING:\tCouldn't read calibration file.")

# Calculate B matric
exp.n_angle_pts = arg.n_angle_pts
exp.calc_B_matrix()

# Load data into memory
import numpy as np
names = ['A_reg_P3.tif', 'A_reg_P4.tif', 'A_reg_P1.tif', 'A_reg_P2.tif',
         'B_reg_P3.tif', 'B_reg_P4.tif', 'B_reg_P1.tif', 'B_reg_P2.tif']
input_files = np.array([arg.data_folder + name for name in names])

# TODO: These should come in via the .cal file
cal = np.array([1.06, 1.0, 1.0, 1.03, 
                1.08, 1.05, 1.0, 1.04])

# Reindexing 
idx = arg.reindex 
input_files = input_files[idx]
cal = cal[idx]

# Load data from file
from polaris import data
intf = data.IntensityField()
intf.load_from_file(file_names=input_files,
                    x0=arg.origin[0], y0=arg.origin[1], z0=arg.origin[2],
                    xs=arg.span[0], ys=arg.span[1], zs=arg.span[2], cal=cal)

# Generate reconstruction mask
threshold_mask = np.max(intf.g, axis=-1) > arg.recon_threshold
sparse_mask = np.zeros(threshold_mask.shape)
sparse_mask[::arg.skip, ::arg.skip, ::arg.skip] = 1
mask = np.logical_and(threshold_mask, sparse_mask)

# Reconstruct
df = exp.recon_dist_field(intf, mask=mask, prior=arg.prior)

# Shuffle data for saving
x, y, z, tp = np.nonzero(df.f_arr)
u = exp.xyz[tp, 0]
v = exp.xyz[tp, 1]
w = exp.xyz[tp, 2]

# Save to .vtu file
from pyevtk.hl import pointsToVTK
import numpy as np
pointsToVTK(arg.output_filename,
            x.astype('float'), y.astype('float'), z.astype('float'),
            data = {"uvw" : (u,v,w)})

# Pass on output file.
log.info('stdout:\t\t'+arg.output_filename+'.vtu')
sys.stdout.write(arg.output_filename+'.vtu')
